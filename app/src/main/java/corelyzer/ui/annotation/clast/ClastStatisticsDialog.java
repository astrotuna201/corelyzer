/******************************************************************************
 *
 * CoreWall / Corelyzer - An Initial Core Description Tool
 * Copyright (C) 2007 Julian Yu-Chung Chen
 * Electronic Visualization Laboratory, University of Illinois at Chicago
 *
 * This software is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either Version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser Public License along
 * with this software; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 * Questions or comments about CoreWall should be directed to
 * cavern@evl.uic.edu
 *
 *****************************************************************************/
package corelyzer.ui.annotation.clast;

import java.awt.FileDialog;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.File;
import java.io.FileWriter;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Locale;
import java.util.Map;

import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.KeyStroke;

import jxl.Workbook;
import jxl.WorkbookSettings;
import jxl.write.Formula;
import jxl.write.Label;
import jxl.write.Number;
import jxl.write.WritableCellFormat;
import jxl.write.WritableFont;
import jxl.write.WritableSheet;
import jxl.write.WritableWorkbook;
import jxl.write.WriteException;

import com.intellij.uiDesigner.core.GridConstraints;
import com.intellij.uiDesigner.core.GridLayoutManager;
import com.intellij.uiDesigner.core.Spacer;

import corelyzer.data.ChatGroup;
import corelyzer.data.CoreSection;
import corelyzer.data.TrackSceneNode;
import corelyzer.graphics.SceneGraph;
import corelyzer.helper.ExampleFileFilter;
import corelyzer.helper.FilenameExtensionFilter;
import corelyzer.ui.CorelyzerApp;
import corelyzer.util.PropertyListUtility;
import corelyzer.util.StringUtility;
import corelyzer.util.TableSorter;

public class ClastStatisticsDialog extends JDialog {
	/**
	 * 
	 */
	private static final long serialVersionUID = -5362545914771758300L;

	public static boolean MAC_OS_X = System.getProperty("os.name").toLowerCase().startsWith("mac os x");

	public static void main(final String[] args) {
		ClastStatisticsDialog dialog = new ClastStatisticsDialog( null );
		dialog.pack();
		dialog.setVisible(true);
		// System.exit(0);
	}

	private JPanel contentPane;
	private JButton buttonUpdate;
	private JButton buttonClose;
	private JButton saveButton;
	private JTable clastTable;

	private JScrollPane clastScrollPane;
	private final ClastTableModel clastTableModel;

	private final Hashtable<String, Integer> fieldToColumnMapping;

	{
		// GUI initializer generated by IntelliJ IDEA GUI Designer
		// >>> IMPORTANT!! <<<
		// DO NOT EDIT OR ADD ANY CODE HERE!
		$$$setupUI$$$();
	}

	public ClastStatisticsDialog( final JFrame owner ) {
		super( owner );
		this.setTitle("Clast Info Statistics");
		setContentPane(contentPane);
		// setModal(true);
		getRootPane().setDefaultButton(saveButton);

		buttonUpdate.addActionListener(new ActionListener() {
			public void actionPerformed(final ActionEvent e) {
				onRefresh();
			}
		});

		buttonClose.addActionListener(new ActionListener() {
			public void actionPerformed(final ActionEvent e) {
				onCancel();
			}
		});

		setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
		addWindowListener(new WindowAdapter() {
			public void windowClosing(final WindowEvent e) {
				onCancel();
			}
		});

		contentPane.registerKeyboardAction(new ActionListener() {
			public void actionPerformed(final ActionEvent e) {
				onCancel();
			}
		}, KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
		saveButton.addActionListener(new ActionListener() {
			public void actionPerformed(final ActionEvent actionEvent) {
				onSave();
			}
		});

		// Table decorations
		this.clastTable.setShowGrid(true);
		this.clastTable.setShowVerticalLines(true);
		this.clastTable.setDragEnabled(true);
		this.clastTable.getTableHeader().setReorderingAllowed(true);

		clastTableModel = new ClastTableModel();
		TableSorter sorter = new TableSorter();
		sorter.setTableModel(clastTableModel);
		sorter.setTableHeader(clastTable.getTableHeader());

		this.clastTable.setModel(sorter);

		// Capitalize first character
		for (int i = 0; i < clastTableModel.indexKeyMapping.length; i++) {
			String header = clastTableModel.indexKeyMapping[i];
			header = this.appendUnit(header);
			header = StringUtility.capitalizeHeadingCharacter(header);
			clastTable.getColumnModel().getColumn(i).setHeaderValue(header);
		}

		fieldToColumnMapping = new Hashtable<String, Integer>();
	}

	/**
	 * @noinspection ALL
	 */
	public JComponent $$$getRootComponent$$$() {
		return contentPane;
	}

	/**
	 * Method generated by IntelliJ IDEA GUI Designer >>> IMPORTANT!! <<< DO NOT
	 * edit this method OR call it in your code!
	 * 
	 * @noinspection ALL
	 */
	private void $$$setupUI$$$() {
		contentPane = new JPanel();
		contentPane.setLayout(new GridLayoutManager(2, 1, new Insets(10, 10, 10, 10), -1, -1));
		final JPanel panel1 = new JPanel();
		panel1.setLayout(new GridLayoutManager(1, 2, new Insets(0, 0, 0, 0), -1, -1));
		contentPane.add(panel1, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK
				| GridConstraints.SIZEPOLICY_CAN_GROW, 1, null, null, null, 0, false));
		final JPanel panel2 = new JPanel();
		panel2.setLayout(new GridLayoutManager(1, 3, new Insets(0, 0, 0, 0), -1, -1));
		panel1.add(panel2, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK
				| GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
		buttonUpdate = new JButton();
		buttonUpdate.setText("Refresh");
		panel2.add(buttonUpdate, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL,
				GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
		buttonClose = new JButton();
		buttonClose.setText("Cancel");
		panel2.add(buttonClose, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL,
				GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
		saveButton = new JButton();
		saveButton.setText("Save...");
		panel2.add(saveButton, new GridConstraints(0, 2, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL,
				GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
		final Spacer spacer1 = new Spacer();
		panel1.add(spacer1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL,
				GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));
		final JPanel panel3 = new JPanel();
		panel3.setLayout(new GridLayoutManager(1, 1, new Insets(0, 0, 0, 0), -1, -1));
		contentPane
				.add(panel3, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK
						| GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null,
						0, false));
		panel3.setBorder(BorderFactory.createTitledBorder("Clast Statistics"));
		clastScrollPane = new JScrollPane();
		clastScrollPane.setHorizontalScrollBarPolicy(32);
		clastScrollPane.setVerticalScrollBarPolicy(22);
		panel3.add(clastScrollPane, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH,
				GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK
						| GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));
		clastTable = new JTable();
		clastScrollPane.setViewportView(clastTable);
	}

	private String appendUnit(String value) {
		if (value.equalsIgnoreCase("width") || value.equalsIgnoreCase("height") || value.equalsIgnoreCase("upperleft") || value.equalsIgnoreCase("lowerright")) {
			value += " (cm)";
		}

		return value;
	}

	private Hashtable<String, Integer> initCountHash() {
		Hashtable<String, Integer> counts = new Hashtable<String, Integer>();
		String[] countableFields = { "granule", "pebble", "cobble", "boulder", // size
				"angular", "sub-angular", "sub-rounded", "rounded", // shape
				"Volcanic", "Granitoid", "Sedimentary", "Metamorphic", "Quartz", "Dolerite", "Intraclast", // lithology
				"vfg", "fg", "mg", "cg" };

		for (String aString : countableFields) {
			counts.put(aString, 0);
		}

		return counts;
	}

	private void onCancel() {
		dispose();
	}

	public void onRefresh() {
		if (clastTableModel != null) {
			clastTableModel.clear();
		}

		CorelyzerApp app = CorelyzerApp.getApp();
		if (app == null) {
			return;
		}

		int numberOfTracks = app.getTrackListModel().size();

		// Traverse current scene and collect clast-group annotation info
		// Track
		for (int i = 0; i < numberOfTracks; i++) {
			TrackSceneNode t = (TrackSceneNode) app.getTrackListModel().elementAt(i);

			int tId = t.getId();
			String trackName = t.getName();
			float trackOffsetX = SceneGraph.getTrackXPos(tId);
			float trackOffsetY = SceneGraph.getTrackYPos(tId);

			System.out.println("---> [Track] " + trackName + " @ " + trackOffsetX + ", " + trackOffsetY);

			// Section
			for (int j = 0; j < t.getNumCores(); j++) {
				CoreSection cs = t.getCoreSection(j);

				int csId = cs.getId();
				String csName = cs.getName();
				float sectionOffsetX = SceneGraph.getSectionXPos(tId, csId);
				float sectionOffsetY = SceneGraph.getSectionYPos(tId, csId);

				// Annotations
				int numberOfMarkers = SceneGraph.getNumCoreSectionMarkers(tId, csId);

				System.out.println("---> [Section] " + csName + " @ " + sectionOffsetX + ", " + sectionOffsetY + ", with " + numberOfMarkers + " markers.");

				for (int k = 0; k < numberOfMarkers; k++) {
					int group = SceneGraph.getCoreSectionMarkerGroup(tId, csId, k);

					String localFile = SceneGraph.getCoreSectionMarkerLocal(tId, csId, k);
					File propFile = new File(localFile);

					if (group != ChatGroup.CLAST || !propFile.exists()) {
						continue;
					}

					Hashtable<String, String> attribs = PropertyListUtility.generateHashtableFromFile(propFile);
					if (attribs == null) {
						continue;
					}

					this.clastTableModel.addAClast(attribs);

					// for convert from gl context coord to abs. meters
					/*
					 * float scale_x = 2.54f / (canvas_dpix * 100.0f); float
					 * scale_y = 2.54f / (canvas_dpiy * 100.0f);
					 * 
					 * float ulx = scale_x *
					 * SceneGraph.getCoreSectionMarkerV0(tId, csId, k); float
					 * uly = scale_y * SceneGraph.getCoreSectionMarkerV1(tId,
					 * csId, k); float lrx = scale_x *
					 * SceneGraph.getCoreSectionMarkerV2(tId, csId, k); float
					 * lry = scale_y * SceneGraph.getCoreSectionMarkerV3(tId,
					 * csId, k);
					 * 
					 * System.out.println("[INFO] " + trackName + ", " + csName
					 * + ", " + " @ (" + ulx + ", " + uly + ") - (" + lrx + ", "
					 * + lry + ") has '" + attribs.size() +
					 * "' clast attributes");
					 */

				} // end of markers
			} // end of section
		} // end of track
	}

	private void onSave() {
		// Save the current table to a Excel or CSV file, collect first
		String dataRoot;

		if (CorelyzerApp.getApp() != null) {
			dataRoot = CorelyzerApp.getApp().preferences().datastore_Directory;
		} else {
			dataRoot = System.getProperty("user.home");
		}

		String dialogTitle = "Choose a file to save";
		String selectedFilePath;

		if (MAC_OS_X) {
			FilenameExtensionFilter filter = new FilenameExtensionFilter("xls");
			FileDialog dlg = new FileDialog(this, dialogTitle, FileDialog.SAVE);
			dlg.setFilenameFilter(filter);
			dlg.setDirectory(dataRoot);
			dlg.setVisible(true);

			String selectedDir = dlg.getDirectory();
			String selectedFile = dlg.getFile();

			if (selectedDir != null && selectedFile != null) {
				selectedFilePath = selectedDir + selectedFile;

				System.out.print("---> MacOSX ");
			} else {
				return;
			}
		} else {
			ExampleFileFilter csvFilter = new ExampleFileFilter("csv", "Commoa Separated Files");
			JFileChooser chooser = new JFileChooser();

			chooser.setCurrentDirectory(new File(dataRoot));
			chooser.setDialogTitle(dialogTitle);
			chooser.resetChoosableFileFilters();
			chooser.setFileFilter(csvFilter);
			int returnVal = chooser.showOpenDialog(this);

			if (returnVal == JFileChooser.APPROVE_OPTION) {
				selectedFilePath = chooser.getSelectedFile().getAbsolutePath();
				System.out.print("---> !MacOSX ");
			} else {
				return;
			}
		}

		// Save file
		System.out.println("choose: '" + selectedFilePath);
		onRefresh();

		if (!saveTableToFile(clastTableModel, selectedFilePath)) {
			JOptionPane.showMessageDialog(this, "Error: file saving failed!");
		}

		dispose();
	}

	private boolean saveAsCSV(final ClastTableModel model, final String aFileName) {
		File aFile = new File(aFileName);

		Date now = new Date(System.currentTimeMillis());
		SimpleDateFormat format = new SimpleDateFormat("MM/dd/yyy 'at' hh:mm:ss z");
		String time = format.format(now);

		try {
			FileWriter fw = new FileWriter(aFile);

			int rowNum = model.getRowCount();
			int colNum = model.getColumnCount();

			String header = "CSV file Generated by Corelyzer at " + time + " \n";
			fw.write(header, 0, header.length());

			for (int i = -1; i < rowNum; i++) {
				for (int j = 0; j < colNum; j++) {
					String value;
					if (i == -1) { // headers
						value = model.indexKeyMapping[j];
						value = this.appendUnit(value);
						value = StringUtility.capitalizeHeadingCharacter(value);
					} else {
						value = (String) model.getValueAt(i, j);
					}

					if (j != colNum - 1) {
						value += ",";
					}

					fw.write(value, 0, value.length());
				}

				fw.write("\n");
			}

			// Track & Section offsets
			CorelyzerApp app = CorelyzerApp.getApp();
			if (app == null) {
				fw.close();
				return true;
			}

			fw.write("Track & Section Offsets (m),\n");
			int numberOfTracks = app.getTrackListModel().size();

			float canvas_dpix = SceneGraph.getCanvasDPIX(0);
			float canvas_dpiy = SceneGraph.getCanvasDPIY(0);
			float scale_x = 2.54f / (canvas_dpix * 100.0f);
			float scale_y = 2.54f / (canvas_dpiy * 100.0f);

			for (int i = 0; i < numberOfTracks; i++) {
				TrackSceneNode t = (TrackSceneNode) app.getTrackListModel().elementAt(i);

				int tId = t.getId();
				String trackName = t.getName();
				float trackOffsetX = SceneGraph.getTrackXPos(tId) * scale_x;
				float trackOffsetY = SceneGraph.getTrackYPos(tId) * scale_y;

				String line = "Track(" + trackName + "), X: " + trackOffsetX + ", Y: " + trackOffsetY + ",\n";
				fw.write(line);

				// Section
				for (int j = 0; j < t.getNumCores(); j++) {
					CoreSection cs = t.getCoreSection(j);

					int csId = cs.getId();
					String csName = cs.getName();
					float sectionOffsetX = SceneGraph.getSectionXPos(tId, csId) * scale_x;
					float sectionOffsetY = SceneGraph.getSectionYPos(tId, csId) * scale_y;

					line = "Section(" + csName + "), X: " + sectionOffsetX + ", Y: " + sectionOffsetY + ",\n";
					fw.write(line);
				}
			}

			fw.close();

			return true;
		} catch (Exception e) {
			System.err.println("---> [EXCEPTION] Writing file '" + aFile + "' failed");
			return false;
		}
	}

	// Save as Excel file
	private boolean saveAsXLS(final String aFileName) {
		try {
			WorkbookSettings ws = new WorkbookSettings();
			ws.setLocale(new Locale("en", "EN"));

			WritableWorkbook workbook = Workbook.createWorkbook(new File(aFileName), ws);

			WritableSheet s1 = workbook.createSheet("Franco Sheet", 0);
			WritableSheet s2 = workbook.createSheet("All clast listing", 1);

			writeFrancoSheet(s1);
			writeAllListSheet(s2, this.clastTableModel);

			workbook.write();
			workbook.close();

			return true;
		} catch (Exception e) {
			System.out.println("Exception! " + e);
			e.printStackTrace();
			return false;
		}
	}

	private boolean saveTableToFile(final ClastTableModel model, final String aFileName) {
		if (aFileName.toLowerCase().endsWith(".csv")) {
			return this.saveAsCSV(model, aFileName);
		} else if (aFileName.toLowerCase().endsWith(".xls")) {
			return this.saveAsXLS(aFileName);
		} else {
			JOptionPane.showMessageDialog(this, "Unknown file extension, will save as 'xls'" + "(Microsoft Excel) file.");
			return saveAsXLS(aFileName);
		}
	}

	private void writeAllListSheet(final WritableSheet sheet, final ClastTableModel model) throws WriteException {
		WritableCellFormat wrappedText = new WritableCellFormat(WritableWorkbook.ARIAL_10_PT);
		wrappedText.setWrap(true);

		int rowNum = model.getRowCount();
		int colNum = model.getColumnCount();

		for (int i = -1; i < rowNum; i++) {
			for (int j = 0; j < colNum; j++) {
				String value;
				if (i == -1) { // headers
					value = model.indexKeyMapping[j];
					value = this.appendUnit(value);
					value = StringUtility.capitalizeHeadingCharacter(value);

					sheet.setColumnView(j, value.length() + 3);
				} else {
					value = (String) model.getValueAt(i, j);
				}

				try {
					Float number = Float.parseFloat(value);
					Number n = new Number(j, i + 1, number);
					sheet.addCell(n);
				} catch (NumberFormatException e) {
					Label l = new Label(j, i + 1, value, wrappedText);
					sheet.addCell(l);
				}
			}
		}

		// Track & Section offsets
		CorelyzerApp app = CorelyzerApp.getApp();
		if (app == null) {
			return;
		}

		rowNum++;
		Label l = new Label(0, rowNum, "Track & Section Offsets (m)");
		sheet.addCell(l);

		int numberOfTracks = app.getTrackListModel().size();

		float canvas_dpix = SceneGraph.getCanvasDPIX(0);
		float canvas_dpiy = SceneGraph.getCanvasDPIY(0);
		float scale_x = 2.54f / (canvas_dpix * 100.0f);
		float scale_y = 2.54f / (canvas_dpiy * 100.0f);

		rowNum++;
		for (int i = 0; i < numberOfTracks; i++) {
			TrackSceneNode t = (TrackSceneNode) app.getTrackListModel().elementAt(i);

			int tId = t.getId();
			String trackName = t.getName();
			float trackOffsetX = SceneGraph.getTrackXPos(tId) * scale_x;
			float trackOffsetY = SceneGraph.getTrackYPos(tId) * scale_y;

			String line = "Track(" + trackName + "), X: " + trackOffsetX + ", Y: " + trackOffsetY;
			l = new Label(0, rowNum, line);
			sheet.addCell(l);
			rowNum++;

			// Section
			for (int j = 0; j < t.getNumCores(); j++) {
				CoreSection cs = t.getCoreSection(j);

				int csId = cs.getId();
				String csName = cs.getName();
				float sectionOffsetX = SceneGraph.getSectionXPos(tId, csId) * scale_x;
				float sectionOffsetY = SceneGraph.getSectionYPos(tId, csId) * scale_y;

				line = "Section(" + csName + "), X: " + sectionOffsetX + ", Y: " + sectionOffsetY + ",\n";
				l = new Label(0, rowNum, line);
				sheet.addCell(l);
				rowNum++;
			}
		}
	}

	private void writeCoreCounts(final WritableSheet sheet, final Hashtable<String, Integer> counts, final int lineToWrite) throws WriteException {
		Enumeration<String> keys = counts.keys();

		while (keys.hasMoreElements()) {
			String aKey = keys.nextElement();
			int count = counts.get(aKey);

			if (count != 0) {
				int columnToWrite;
				if (this.fieldToColumnMapping.get(aKey) != null) {
					columnToWrite = this.fieldToColumnMapping.get(aKey);
				} else {
					columnToWrite = 0;
				}

				Number n = new Number(columnToWrite, lineToWrite, count);
				sheet.addCell(n);
			}
		}
	}

	private void writeFrancoHeaders(final WritableSheet sheet) throws WriteException {
		WritableFont arial12font = new WritableFont(WritableFont.ARIAL, 12, WritableFont.BOLD, true);
		WritableCellFormat arial12format = new WritableCellFormat(arial12font);

		WritableFont arial10font = new WritableFont(WritableFont.ARIAL, 10, WritableFont.BOLD, true);
		WritableCellFormat arial10format = new WritableCellFormat(arial10font);

		Label l = new Label(24, 0, "ADDITIONAL FEATURES for specific clasts");
		sheet.addCell(l);

		l = new Label(5, 1, "CLAST SIZE", arial12format);
		sheet.addCell(l);
		l = new Label(10, 1, "CLAST SHAPE", arial12format);
		sheet.addCell(l);
		l = new Label(15, 1, "CLAST LITHOLOGY", arial12format);
		sheet.addCell(l);
		l = new Label(24, 1, "Colour", arial12format);
		sheet.addCell(l);
		l = new Label(25, 1, "Grain-size", arial12format);
		sheet.addCell(l);
		l = new Label(29, 1, "Texture", arial12format);
		sheet.addCell(l);
		l = new Label(30, 1, "Minerals", arial12format);
		sheet.addCell(l);
		l = new Label(31, 1, "Note", arial12format);
		sheet.addCell(l);
		l = new Label(32, 1, "SAMPLE no.(TAL)", arial12format);
		sheet.addCell(l);

		l = new Label(3, 2, "Depth (mbsf)", arial10format);
		sheet.addCell(l);
		l = new Label(5, 2, "granule", arial10format);
		fieldToColumnMapping.put("granule", 5);
		sheet.addCell(l);
		l = new Label(6, 2, "pebble", arial10format);
		fieldToColumnMapping.put("pebble", 6);
		sheet.addCell(l);
		l = new Label(7, 2, "cobble", arial10format);
		fieldToColumnMapping.put("cobble", 7);
		sheet.addCell(l);
		l = new Label(8, 2, "boulder", arial10format);
		fieldToColumnMapping.put("boulder", 8);
		sheet.addCell(l);
		l = new Label(25, 2, "vfg", arial10format);
		fieldToColumnMapping.put("vfg", 25);
		sheet.addCell(l);
		l = new Label(26, 2, "fg", arial10format);
		fieldToColumnMapping.put("fg", 26);
		sheet.addCell(l);
		l = new Label(27, 2, "mg", arial10format);
		fieldToColumnMapping.put("mg", 27);
		sheet.addCell(l);
		l = new Label(28, 2, "cg", arial10format);
		fieldToColumnMapping.put("cg", 28);
		sheet.addCell(l);

		l = new Label(0, 3, "Core", arial10format);
		sheet.addCell(l);
		l = new Label(1, 3, "Top", arial10format);
		sheet.addCell(l);
		l = new Label(2, 3, "Bottom", arial10format);
		sheet.addCell(l);
		l = new Label(3, 3, "Mean", arial10format);
		sheet.addCell(l);
		l = new Label(5, 3, "(2-4 mm)", arial10format);
		sheet.addCell(l);
		l = new Label(6, 3, "(4-64 mm)", arial10format);
		sheet.addCell(l);
		l = new Label(7, 3, "(64-256 mm)", arial10format);
		sheet.addCell(l);
		l = new Label(8, 3, "(> 256 mm)", arial10format);
		sheet.addCell(l);
		l = new Label(10, 3, "angular", arial10format);
		fieldToColumnMapping.put("angular", 10);
		sheet.addCell(l);
		l = new Label(11, 3, "sub-angular", arial10format);
		fieldToColumnMapping.put("sub-angular", 11);
		sheet.addCell(l);
		l = new Label(12, 3, "sub-rounded", arial10format);
		fieldToColumnMapping.put("sub-rounded", 12);
		sheet.addCell(l);
		l = new Label(13, 3, "rounded", arial10format);
		fieldToColumnMapping.put("rounded", 13);
		sheet.addCell(l);
		l = new Label(15, 3, "Volcanic", arial10format);
		fieldToColumnMapping.put("Volcanic", 15);
		sheet.addCell(l);
		l = new Label(16, 3, "Granitoid", arial10format);
		fieldToColumnMapping.put("Granitoid", 16);
		sheet.addCell(l);
		l = new Label(17, 3, "Sedimentary", arial10format);
		fieldToColumnMapping.put("Sedimentary", 17);
		sheet.addCell(l);
		l = new Label(18, 3, "Metamorphic", arial10format);
		fieldToColumnMapping.put("Metamorphic", 18);
		sheet.addCell(l);
		l = new Label(19, 3, "Quartz", arial10format);
		fieldToColumnMapping.put("Quartz", 19);
		sheet.addCell(l);
		l = new Label(20, 3, "Dolerite", arial10format);
		fieldToColumnMapping.put("Dolerite", 20);
		sheet.addCell(l);
		l = new Label(21, 3, "Intraclast", arial10format);
		fieldToColumnMapping.put("Intraclast", 21);
		sheet.addCell(l);
		l = new Label(23, 3, "Total No. Clasts", arial10format);
		sheet.addCell(l);
	}

	private void writeFrancoSheet(final WritableSheet sheet) throws WriteException {
		this.writeFrancoHeaders(sheet);

		CorelyzerApp app = CorelyzerApp.getApp();
		if (app == null) {
			return;
		}

		int numberOfTracks = app.getTrackListModel().size();

		// float canvas_dpix = SceneGraph.getCanvasDPIX(0);
		// float canvas_dpiy = SceneGraph.getCanvasDPIY(0);

		// float scale_x = 2.54f / (canvas_dpix * 100.0f);
		// float scale_y = 2.54f / (canvas_dpiy * 100.0f);

		// write after headers
		int lineToWrite = 4;
		for (int i = 0; i < numberOfTracks; i++) {
			TrackSceneNode t = (TrackSceneNode) app.getTrackListModel().elementAt(i);

			int tId = t.getId();
			int numberOfSections = t.getNumCores();

			for (int j = 0; j < numberOfSections; j++) {
				CoreSection cs = t.getCoreSection(j);

				int csId = cs.getId();
				String csName = cs.getName();

				Label l = new Label(0, lineToWrite, csName);
				sheet.addCell(l);

				int numberOfMarkers = SceneGraph.getNumCoreSectionMarkers(tId, csId);

				// / if (numberOfMarkers > 0) {
				// mbsf
				float sectionDepth = SceneGraph.getSectionDepth(tId, csId) / 100.0f;

				float coreLength = SceneGraph.getSectionLength(tId, csId) / 100.0f;

				// System.out.println("---> [INFO] TopDepth, Length: " +
				// sectionDepth + ", " + coreLength);

				Number topDepth = new Number(1, lineToWrite, sectionDepth);
				sheet.addCell(topDepth);

				Number bottomDepth = new Number(2, lineToWrite, (sectionDepth + coreLength));
				sheet.addCell(bottomDepth);

				Number meanDepth = new Number(3, lineToWrite, (sectionDepth + coreLength / 2));
				sheet.addCell(meanDepth);

				Hashtable<String, Integer> typeCount = initCountHash();

				for (int k = 0; k < numberOfMarkers; k++) {
					int group = SceneGraph.getCoreSectionMarkerGroup(tId, csId, k);

					String localFile = SceneGraph.getCoreSectionMarkerLocal(tId, csId, k);
					File propFile = new File(localFile);

					if (group != ChatGroup.CLAST || !propFile.exists()) {
						continue;
					}

					Hashtable<String, String> attribs = PropertyListUtility.generateHashtableFromFile(propFile);

					if (attribs == null) {
						continue;
					}

					// Look at attribs and counting...
					String mode = attribs.get("mode");

					for (Map.Entry<String, String> entry : attribs.entrySet()) {
						String key = entry.getKey();
						String value = entry.getValue();

						if (mode == null || mode.equalsIgnoreCase("single") || mode.equals("")) {
							if (typeCount.containsKey(value)) {
								int count = typeCount.get(value) + 1;
								typeCount.put(value, count);
							}
						} else if (mode.equalsIgnoreCase("multiple")) {
							for (Map.Entry<String, Integer> e : typeCount.entrySet()) {

								String typeKey = e.getKey();
								int count = e.getValue();

								if (key.toLowerCase().startsWith(typeKey.toLowerCase()) && key.toLowerCase().endsWith("count")) {

									int addValue;
									try {
										addValue = Integer.valueOf(value);
									} catch (NumberFormatException nfe) {
										System.err.println("" + nfe);
										addValue = 0;
									}

									count += addValue;
									typeCount.put(typeKey, count);
								}
							}
						}
					}
				} // end of marker-loop

				writeCoreCounts(sheet, typeCount, lineToWrite);

				// FIXME, Looks weird in Office in MacOSX
				String formulaString = "SUM(P" + (lineToWrite + 1) + ":U" + (lineToWrite + 1);
				Formula f = new Formula(23, lineToWrite, formulaString);
				sheet.addCell(f);

				lineToWrite++;
				// / } // end of numberOfMarkers > 0 check
			} // end of section-loop
		} // end of track-loop
	}
}
