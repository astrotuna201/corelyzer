/******************************************************************************
 *
 * CoreWall / Corelyzer - An Initial Core Description Tool
 * Copyright (C) 2008 Julian Yu-Chung Chen
 * Electronic Visualization Laboratory, University of Illinois at Chicago
 *
 * This software is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either Version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser Public License along
 * with this software; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 * Questions or comments about CoreWall should be directed to
 * cavern@evl.uic.edu
 *
 *****************************************************************************/

package corelyzer.ui;

import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.text.DecimalFormat;
import java.util.Random;
import java.util.Vector;

import javax.swing.DefaultComboBoxModel;
import javax.swing.DefaultListModel;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextField;
import javax.swing.KeyStroke;
import javax.swing.ListSelectionModel;
import javax.swing.SwingUtilities;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;

import com.intellij.uiDesigner.core.GridConstraints;
import com.intellij.uiDesigner.core.GridLayoutManager;
import com.intellij.uiDesigner.core.Spacer;

import corelyzer.data.CheckBoxTable;
import corelyzer.data.CoreSection;
import corelyzer.data.CoreSectionGraph;
import corelyzer.data.Session;
import corelyzer.data.TrackSceneNode;
import corelyzer.data.UnitLength;
import corelyzer.data.WellLogDataSet;
import corelyzer.data.WellLogTable;
import corelyzer.data.coregraph.CoreGraph;
import corelyzer.data.lists.CRDefaultListModel;
import corelyzer.graphics.SceneGraph;

// TODO: update states more accurtely.
public class CRGraphDialog extends JFrame {
	/**
	 * 
	 */
	private static final long serialVersionUID = -8879622939957228395L;

	public static void main(final String[] args) {
		CRGraphDialog dialog = new CRGraphDialog(null);
		dialog.pack();
		dialog.setSize(480, 480);
		dialog.setLocationRelativeTo(null);
		dialog.setVisible(true);
	}

	private JPanel contentPane;
	private JButton applybtn;
	private JButton closebtn;
	private JComboBox datasetList;
	private JCheckBox allSections;
	private JList sectionsList;
	private JCheckBox ifCollapseGraphs;
	private JButton colorbtn;
	private JComboBox typeList;
	private JTextField minText;
	private JTextField maxText;
	private JLabel valueMin;
	private JLabel valueMax;

	private CheckBoxTable fieldsTable;
	DefaultComboBoxModel datasetModel;

	DefaultListModel sectionsListModel;
	// View (for scaling)
	Vector<Float> minVals;

	Vector<Float> maxVals;
	// Data (original field data)
	Vector<Float> origMinVals;

	Vector<Float> origMaxVals;
	// Min/max values in all sections/tables
	Vector<Float> allMinVals;

	Vector<Float> allMaxVals;
	Vector<Color> colors;

	Vector<Integer> types; // line, point, crosspoint

	Vector<WellLogDataSet> datasets;

	ColorChooser colorchooser;

	// int currentDatasetIndex;
	int currentTableIndex;
	int selectedTrackId; // native code index (scenegraph)
	int selectedSectionId; // native code index (sceengraph)
	int selectedTrackListId; // java side index (CorelyzerApp)
	int selectedSectionListId; // java side index (CorelyzerApp)
	int selectedFieldId;

	int lastSelectedField;

	{
		// GUI initializer generated by IntelliJ IDEA GUI Designer
		// >>> IMPORTANT!! <<<
		// DO NOT EDIT OR ADD ANY CODE HERE!
		$$$setupUI$$$();
	}

	public CRGraphDialog(final Component parent) {
		super();
		this.setAlwaysOnTop(true);
		this.setLocationRelativeTo(parent);
		setTitle("Graph Dialog");

		myInit();

		setContentPane(contentPane);
		getRootPane().setDefaultButton(applybtn);

		applybtn.addActionListener(new ActionListener() {

			public void actionPerformed(final ActionEvent e) {
				onApply();
			}
		});

		closebtn.addActionListener(new ActionListener() {

			public void actionPerformed(final ActionEvent e) {
				onCancel();
			}
		});

		setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
		addWindowListener(new WindowAdapter() {

			@Override
			public void windowClosing(final WindowEvent e) {
				onCancel();
			}
		});

		contentPane.registerKeyboardAction(new ActionListener() {

			public void actionPerformed(final ActionEvent e) {
				onCancel();
			}
		}, KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);

		typeList.addActionListener(new ActionListener() {

			public void actionPerformed(final ActionEvent event) {
				onTypeListAction();
			}
		});
	}

	/**
	 * @noinspection ALL
	 */
	public JComponent $$$getRootComponent$$$() {
		return contentPane;
	}

	/**
	 * Method generated by IntelliJ IDEA GUI Designer >>> IMPORTANT!! <<< DO NOT
	 * edit this method OR call it in your code!
	 * 
	 * @noinspection ALL
	 */
	private void $$$setupUI$$$() {
		contentPane = new JPanel();
		contentPane.setLayout(new GridLayoutManager(2, 1, new Insets(10, 10, 10, 10), -1, -1));
		final JPanel panel1 = new JPanel();
		panel1.setLayout(new GridLayoutManager(1, 3, new Insets(0, 0, 0, 0), -1, -1));
		contentPane.add(panel1, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK
				| GridConstraints.SIZEPOLICY_CAN_GROW, 1, null, null, null, 0, false));
		final Spacer spacer1 = new Spacer();
		panel1.add(spacer1, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL,
				GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));
		final JPanel panel2 = new JPanel();
		panel2.setLayout(new GridLayoutManager(1, 2, new Insets(0, 0, 0, 0), -1, -1));
		panel1.add(panel2, new GridConstraints(0, 2, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK
				| GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
		closebtn = new JButton();
		closebtn.setText("Close");
		panel2.add(closebtn, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL,
				GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
		applybtn = new JButton();
		applybtn.setText("Apply");
		panel2.add(applybtn, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL,
				GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
		ifCollapseGraphs = new JCheckBox();
		ifCollapseGraphs.setText("Collapse Graphs?");
		panel1.add(ifCollapseGraphs, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE,
				GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
		final JPanel panel3 = new JPanel();
		panel3.setLayout(new GridLayoutManager(2, 1, new Insets(0, 0, 0, 0), -1, -1));
		contentPane
				.add(panel3, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK
						| GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null,
						0, false));
		final JPanel panel4 = new JPanel();
		panel4.setLayout(new GridLayoutManager(7, 1, new Insets(0, 0, 0, 0), -1, -1));
		panel3.add(panel4, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK
				| GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
		final JLabel label1 = new JLabel();
		label1.setText("Choose a dataset:");
		panel4.add(label1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,
				GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
		datasetList = new JComboBox();
		final DefaultComboBoxModel defaultComboBoxModel1 = new DefaultComboBoxModel();
		defaultComboBoxModel1.addElement("RGR_TEST.xml");
		datasetList.setModel(defaultComboBoxModel1);
		panel4.add(datasetList, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL,
				GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
		allSections = new JCheckBox();
		allSections.setSelected(true);
		allSections.setText("Apply to all sections in this dataset?");
		panel4.add(allSections, new GridConstraints(2, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_CAN_SHRINK
				| GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
		final JLabel label2 = new JLabel();
		label2.setText("Choose graph section: ");
		panel4.add(label2, new GridConstraints(3, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,
				GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
		final JLabel label3 = new JLabel();
		label3.setText("Properties fields: ");
		panel4.add(label3, new GridConstraints(5, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,
				GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
		final JScrollPane scrollPane1 = new JScrollPane();
		panel4.add(scrollPane1, new GridConstraints(6, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK
				| GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0,
				false));
		fieldsTable = new CheckBoxTable();
		scrollPane1.setViewportView(fieldsTable);
		final JScrollPane scrollPane2 = new JScrollPane();
		panel4.add(scrollPane2, new GridConstraints(4, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK
				| GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0,
				false));
		sectionsList = new JList();
		final DefaultListModel defaultListModel1 = new DefaultListModel();
		sectionsList.setModel(defaultListModel1);
		scrollPane2.setViewportView(sectionsList);
		final JPanel panel5 = new JPanel();
		panel5.setLayout(new GridLayoutManager(3, 2, new Insets(0, 0, 0, 0), -1, -1));
		panel3.add(panel5, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK
				| GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
		valueMin = new JLabel();
		valueMin.setText("Value min: -100.0");
		panel5.add(valueMin, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,
				GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(153, 16), null, 0, false));
		final JPanel panel6 = new JPanel();
		panel6.setLayout(new GridLayoutManager(1, 2, new Insets(0, 0, 0, 0), -1, -1));
		panel5.add(panel6, new GridConstraints(1, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK
				| GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
		final JLabel label4 = new JLabel();
		label4.setText("Scale min: ");
		panel6.add(label4, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,
				GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
		minText = new JTextField();
		minText.setHorizontalAlignment(11);
		panel6.add(minText, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW,
				GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));
		colorbtn = new JButton();
		colorbtn.setText("Color");
		panel5.add(colorbtn, new GridConstraints(2, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL,
				GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(153, 29),
				null, 0, false));
		typeList = new JComboBox();
		final DefaultComboBoxModel defaultComboBoxModel2 = new DefaultComboBoxModel();
		defaultComboBoxModel2.addElement("Line");
		defaultComboBoxModel2.addElement("Point");
		defaultComboBoxModel2.addElement("Cross point");
		typeList.setModel(defaultComboBoxModel2);
		panel5.add(typeList, new GridConstraints(2, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_GROW,
				GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
		valueMax = new JLabel();
		valueMax.setText("Value max: +100.0");
		panel5.add(valueMax, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,
				GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(153, 16), null, 0, false));
		final JPanel panel7 = new JPanel();
		panel7.setLayout(new GridLayoutManager(1, 2, new Insets(0, 0, 0, 0), -1, -1));
		panel5.add(panel7, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK
				| GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
		final JLabel label5 = new JLabel();
		label5.setText("Scale max: ");
		panel7.add(label5, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,
				GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
		maxText = new JTextField();
		maxText.setHorizontalAlignment(11);
		panel7.add(maxText, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW,
				GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));
	}

	private void applyGraphSelection(final int section) {
		if (section < 0) {
			return;
		}

		WellLogDataSet ds = (WellLogDataSet) this.datasetList.getSelectedItem();

		// loop through field list, check each checkbox' status
		for (int i = 0; i < fieldsTable.getRowCount(); i++) {
			boolean isChecked = fieldsTable.isRowChecked(i);

			if (isChecked) {
				// get the graph id and set the min/max and color values
				// apply the changes to the graph. If there isn't a graph
				// then create it, if possible

				int gid = SceneGraph.getGraphID(selectedTrackId, section, ds.getId(), // currentDatasetIndex,
						currentTableIndex, i);

				if (gid < 0) {
					gid = SceneGraph.addLineGraphToSection(selectedTrackId, section, ds.getId(), // getDatasetId(currentDatasetIndex),
							currentTableIndex, i);

					String fn = this.fieldsTable.getRowLabel(i);
					SceneGraph.setLineGraphLabel(gid, fn);
				}

				if (gid == -1) {
					System.out.println("- GraphID of -1 after calling SceneGraph.addLineGraphToSection.");
					continue;
				}

				SceneGraph.setLineGraphRange(gid, minVals.elementAt(i), maxVals.elementAt(i));

				Color c = colors.elementAt(i);

				SceneGraph.setLineGraphColor(gid, (c.getRed() / 255.0f), (c.getGreen() / 255.0f), (c.getBlue() / 255.0f));
				Integer t = types.elementAt(i);
				SceneGraph.setLineGraphType(gid, t);
			} else {
				// make sure it's removed if there exists a graph
				int gid = SceneGraph.getGraphID(selectedTrackId, section, ds.getId(), // currentDatasetIndex,
						currentTableIndex, i);

				if (gid >= 0) {
					SceneGraph.removeLineGraphFromSection(gid);
				}
			}
		}
	}

	private int getTableIndex(final int sectionId) {
		// get section name from sectionId
		CRDefaultListModel smodel = CorelyzerApp.getApp().getSectionListModel();
		String secname = smodel.getElementAt(sectionId).toString();

		// get dataset tables
		// WellLogDataSet ds =
		// this.datasets.elementAt(this.currentDatasetIndex);
		WellLogDataSet ds = (WellLogDataSet) this.datasetList.getSelectedItem();

		if (ds == null) {
			return -1;
		}

		for (int i = 0; i < ds.getNumTables(); i++) {
			WellLogTable t = ds.getTable(i);

			String tableName = t.getName().toLowerCase();

			// only pick up the table/section name matched with selected
			// image section filename, and ignore case...
			if (secname.compareToIgnoreCase(tableName) == 0) {
				return i;
			}
		}

		return -1;

	}

	private void ifCollapseAction() {
		SwingUtilities.invokeLater(new Runnable() {

			public void run() {
				SceneGraph.setGraphsCollapse(ifCollapseGraphs.isSelected());

				CorelyzerApp.getApp().updateGLWindows();
			}
		});
	}

	private void myInit() {
		// data
		// currentDatasetIndex = -1;
		currentTableIndex = -1;
		selectedFieldId = -1;
		selectedTrackId = -1;
		selectedSectionId = -1;

		// ui
		this.colorchooser = new ColorChooser(this);
		this.colorchooser.setVisible(false);
		this.colorchooser.addReturnActionListener(new ActionListener() {

			public void actionPerformed(final ActionEvent event) {
				onColorChooserReturn();
			}
		});

		this.datasetModel = new DefaultComboBoxModel();
		this.datasetList.setModel(datasetModel);
		this.datasetList.addActionListener(new ActionListener() {

			public void actionPerformed(final ActionEvent e) {
				onDatasetAction();
			}
		});

		this.allSections.addActionListener(new ActionListener() {

			public void actionPerformed(final ActionEvent e) {
				onAllSectionsAction();
			}
		});

		this.sectionsListModel = new DefaultListModel();
		this.sectionsList.setModel(this.sectionsListModel);
		this.sectionsList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		this.sectionsList.addListSelectionListener(new ListSelectionListener() {

			public void valueChanged(final ListSelectionEvent event) {
				onSectionsListChanged();
			}
		});

		fieldsTable.setShowHorizontalLines(true);
		fieldsTable.addCheckEventListener(new TableModelListener() {

			public void tableChanged(final TableModelEvent event) {
				onFieldsTableChanged(event);
			}
		});
		fieldsTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {

			public void valueChanged(final ListSelectionEvent event) {
				onFieldsListChanged();
			}
		});

		colors = new Vector<Color>();
		types = new Vector<Integer>();
		minVals = new Vector<Float>();
		maxVals = new Vector<Float>();

		this.origMinVals = new Vector<Float>();
		this.origMaxVals = new Vector<Float>();
		this.allMinVals = new Vector<Float>();
		this.allMaxVals = new Vector<Float>();

		colorbtn.addActionListener(new ActionListener() {

			public void actionPerformed(final ActionEvent e) {
				onColorButton();
			}
		});
		minText.addFocusListener(new FocusListener() {

			public void focusGained(final FocusEvent event) {
			}

			public void focusLost(final FocusEvent event) {
				onMinTextLostFocus();
			}
		});
		maxText.addFocusListener(new FocusListener() {

			public void focusGained(final FocusEvent event) {
			}

			public void focusLost(final FocusEvent event) {
				onMaxTextLostFocus();
			}
		});

		ifCollapseGraphs.setSelected(SceneGraph.getGraphsCollapse());
		ifCollapseGraphs.addActionListener(new ActionListener() {

			public void actionPerformed(final ActionEvent event) {
				ifCollapseAction();
			}
		});
	}

	private void onAllSectionsAction() {
		this.onFieldsListChanged();
	}

	private void onApply() {
		// APPLY BUTTON
		if (allSections.isSelected()) {
			int numsecs = SceneGraph.getNumSections(selectedTrackId);
			int temp = currentTableIndex;

			for (int i = 0; i < numsecs; i++) {
				currentTableIndex = this.getTableIndex(i);
				applyGraphSelection(i);
			}

			currentTableIndex = temp;
		} else {
			applyGraphSelection(selectedSectionId);
		}

		CorelyzerApp.getApp().updateGLWindows();
	}

	private void onCancel() {
		dispose();
	}

	private void onColorButton() {
		this.colorchooser.setVisible(true);
		this.colorchooser.setTarget(this.colorbtn);
		int field = fieldsTable.getSelectedRow();
		this.colorchooser.setColor(colors.elementAt(field));
	}

	private void onColorChooserReturn() {
		// COLOR SELECTED
		int field = fieldsTable.getSelectedRow();
		if (field < 0) {
			return;
		}

		colors.setElementAt(colorchooser.getColor(), field);

		// update current section info f i x m e
		CRDefaultListModel tmodel = CorelyzerApp.getApp().getTrackListModel();
		TrackSceneNode tnode = (TrackSceneNode) tmodel.elementAt(selectedTrackListId);
		String secname = this.sectionsListModel.getElementAt(this.selectedSectionListId).toString();

		CoreSection sec = tnode.getCoreSection(secname);
		if (sec == null) {
			this.selectedSectionId = -1;
		} else {
			this.selectedSectionId = sec.getId();
		}

		WellLogDataSet ds = (WellLogDataSet) this.datasetList.getSelectedItem();

		// if there is a graph already there then change the color of
		// the graph
		int gid = SceneGraph.getGraphID(selectedTrackId, selectedSectionId, ds.getId(), // getDatasetId(currentDatasetIndex),
				currentTableIndex, field);
		if (gid < 0) {
			return;
		}

		Color c = colors.elementAt(field);
		SceneGraph.setLineGraphColor(gid, (c.getRed() / 255.0f), (c.getGreen() / 255.0f), (c.getBlue() / 255.0f));

		this.onApply();
	}

	private void onDatasetAction() {
		// DATASET COMBOBOX
		/*
		 * int idx = this.datasetList.getSelectedIndex();
		 * 
		 * if (idx < 0) return;
		 * 
		 * String dsName = (String) this.datasetList.getSelectedItem();
		 * 
		 * System.out.println("---- Selected Dataset " + dsName + " idx: " +
		 * idx);
		 * 
		 * // set dataset index and update fields
		 * CorelyzerApp.getApp().getDataFileList().setSelectedIndex(idx);
		 * this.currentDatasetIndex = idx; this.repaint(); lastSelectedField =
		 * 0;
		 * 
		 * // update section list for this dataset
		 * this.sectionsListModel.removeAllElements(); WellLogDataSet ds =
		 * this.datasets.elementAt(idx); for (int i = 0; i < ds.getNumTables();
		 * i++) { String name = ds.getTable(i).getName();
		 * this.sectionsListModel.addElement(name); }
		 * //this.selectedSectionListId = this.sectionsList.getSelectedIndex();
		 * this.selectedSectionListId = 0;
		 * this.sectionsList.setSelectedIndex(0);
		 * 
		 * fieldsTable.tableChanged(new TableModelEvent(
		 * fieldsTable.getModel()));
		 */
		WellLogDataSet ds = (WellLogDataSet) this.datasetList.getSelectedItem();
		if (ds == null) {
			return;
		}

		// System.out.println("[Bremen] Selected dataset: " + ds.toString() +
		// ", id: " + ds.getId());

		CoreGraph cg = CoreGraph.getInstance();
		Session s = cg.getCurrentSession();
		if (s != null) {
			for (int i = 0; i < s.getDatasets().size(); i++) {
				WellLogDataSet d = s.getDatasets().elementAt(i);

				if (d.getId() == ds.getId()) {
					// System.out.println("[Bremen] Found dataset index in session: "
					// + s.getName() + ", index: " + i
					// + ", id: " + ds.getId());

					cg.setCurrentDatasetIdx(i);

					// this.currentDatasetIndex = i;
					this.repaint();

					break;
				}
			}
		}

		this.sectionsListModel.removeAllElements();
		for (int i = 0; i < ds.getNumTables(); i++) {
			String name = ds.getTable(i).getName();
			this.sectionsListModel.addElement(name);
		}
		// this.selectedSectionListId = this.sectionsList.getSelectedIndex();
		this.selectedSectionListId = 0;
		this.sectionsList.setSelectedIndex(0);

		fieldsTable.tableChanged(new TableModelEvent(fieldsTable.getModel()));
	}

	// ---------------------------------------------------------------

	private void onFieldsListChanged() {
		// if (currentDatasetIndex < 0) {
		WellLogDataSet ds = (WellLogDataSet) this.datasetList.getSelectedItem();

		if (ds == null) {
			return;
		}

		int field = fieldsTable.getSelectedRow();
		if (field < 0) {
			return;
		}

		lastSelectedField = field;

		// (View) update min/max text with the values of selected field index
		minText.setText(minVals.elementAt(field).toString());
		maxText.setText(maxVals.elementAt(field).toString());

		// (Data) Update field's min/max values
		DecimalFormat df = new DecimalFormat("#,###,###,##0.000");
		float allValueMin = this.allSections.isSelected() ? this.allMinVals.elementAt(field) : this.origMinVals.elementAt(field);
		float allValueMax = this.allSections.isSelected() ? this.allMaxVals.elementAt(field) : this.origMaxVals.elementAt(field);

		this.valueMin.setText("Value min: " + df.format(allValueMin));
		this.valueMax.setText("Value max: " + df.format(allValueMax));

		colorbtn.setBackground(colors.elementAt(field));
		typeList.setSelectedIndex(types.elementAt(field));

		repaint();
	}

	private void onFieldsTableChanged(final TableModelEvent event) {
		int row = event.getFirstRow();
		boolean checked = fieldsTable.isRowChecked(row);

		if (!checked) {
			// if there is a graph id to match the
			// track, section, dataset, table, field attributes
			// then have it removed, and for each section in the track

			WellLogDataSet ds = (WellLogDataSet) this.datasetList.getSelectedItem();

			if (!allSections.isSelected()) {
				int gid = SceneGraph.getGraphID(selectedTrackId, selectedSectionId, ds.getId(), // currentDatasetIndex,
						currentTableIndex, row);

				SceneGraph.removeLineGraphFromSection(gid);

			} else {
				CoreGraph cg = CoreGraph.getInstance();
				TrackSceneNode tnode = cg.getCurrentTrack();

				if (tnode != null) {
					for (int i = 0; i < tnode.getNumCores(); i++) {
						CoreSection cs = tnode.getCoreSection(i);

						if (cs != null) {
							int tid = this.getTableIndex(i);
							int gid = SceneGraph.getGraphID(selectedTrackId, cs.getId(), ds.getId(), // currentDatasetIndex,
									tid, row);

							SceneGraph.removeLineGraphFromSection(gid);
						} else {
							System.out.println("- cs is null!");
						}
					}
				} else {
					System.out.println("- tnode is null!");
				}
			}
		} // end removing graphs
		else // adding graphs
		{
			if (!allSections.isSelected()) {
				// add one graph
				// coresection exist?
				CRDefaultListModel tmodel = CorelyzerApp.getApp().getTrackListModel();
				TrackSceneNode tnode = (TrackSceneNode) tmodel.elementAt(selectedTrackListId);
				String secname = this.sectionsListModel.getElementAt(this.selectedSectionListId).toString();
				CoreSection sec = tnode.getCoreSection(secname);
				boolean justAppend = false;

				// If the dataset table contains section depth offset, use it.
				WellLogDataSet ds = (WellLogDataSet) this.datasetModel.getSelectedItem();
				WellLogTable table = ds.getTable(this.currentTableIndex);

				if (sec == null) {
					// need to creat new section
					// native first, java next for gid
					int secid = SceneGraph.addSectionToTrack(tnode.getId(), tnode.getNumCores());
					SceneGraph.setSectionName(tnode.getId(), secid, secname);
					// property?
					sec = new CoreSection(secname, secid);
					tnode.addCoreSection(sec);
					CoreGraph.getInstance().notifyListeners();

					float unitScale;
					switch (table.getDepthUnits()) {
						case UnitLength.CM:
							unitScale = 0.01f;
							break;

						case UnitLength.M:
							unitScale = 1.0f;
							break;

						case UnitLength.FOOT:
							unitScale = 0.3048f;
							break;

						case UnitLength.INCH:
							unitScale = 0.0254f;
							break;

						case UnitLength.MM:
							unitScale = 0.001f;
							break;

						case UnitLength.YARD:
							unitScale = 0.9144f;
							break;

						default:
							unitScale = 1.0f;
					}

					// Figure out the top depth of a section
					float sectionBeginDepth;
					float sectionTopDepth = table.getTopDepth(); // in meters

					if (sectionTopDepth != -1) {
						sectionBeginDepth = sectionTopDepth;
					} else if (table.getDepth_offset() != -1) {
						sectionBeginDepth = table.getDepth_offset() * unitScale;
					} else {
						sectionBeginDepth = 0.0f;
						justAppend = true;
					}

					SceneGraph.positionSection(tnode.getId(), secid, sectionBeginDepth * 100.0f / 2.54f * SceneGraph.getCanvasDPIX(0), 0);
				}

				// if we created new coresection and add new graph
				// but has no sectionTopDepth or depth_offset
				// send section to the end of the track
				if (justAppend) {
					SceneGraph.pushSectionToEnd(tnode.getId(), sec.getId());
					sec.setDepth(SceneGraph.getSectionDepth(tnode.getId(), sec.getId()));
				}

				// now we have the section
				// native first, java next for gid
				// System.out.println("[Bremen] Creating graph using dataset: "
				// + ds.toString()
				// + " with id: " + ds.getId() + ", tableIdx: " +
				// this.currentTableIndex);

				int gid = SceneGraph.addLineGraphToSection(tnode.getId(), sec.getId(), ds.getId(), currentTableIndex, row);

				if (gid == -1) {
					System.out.println("- Creating graph, but gid is: " + gid);
					return;
				}

				SceneGraph.setLineGraphRange(gid, minVals.elementAt(row), maxVals.elementAt(row));

				Color c = colors.elementAt(row);

				SceneGraph.setLineGraphColor(gid, (c.getRed() / 255.0f), (c.getGreen() / 255.0f), (c.getBlue() / 255.0f));

				Integer t = types.elementAt(row);
				SceneGraph.setLineGraphType(gid, t);

				String fn = this.fieldsTable.getRowLabel(row);
				SceneGraph.setLineGraphLabel(gid, fn);

				// java side
				CoreSectionGraph csg = new CoreSectionGraph(ds.getId(), // currentDatasetIndex,
						currentTableIndex, row, gid, tnode);
				csg.setName(secname);
				tnode.addCoreSectionGraph(csg, sec.getId(), gid);

				// update currnet gid : native code id
				this.selectedTrackId = tnode.getId();
				this.selectedSectionId = sec.getId();
			} else {
				// now, we create all sections' graph in current dataset
				// read tablenames from dataset
				// check its existence in section list
				// if not, create section and add graph
				// or, add graph
				// WellLogDataSet ds = datasets.elementAt(currentDatasetIndex);
				WellLogDataSet ds = (WellLogDataSet) this.datasetList.getSelectedItem();
				if (ds == null) {
					System.out.println("- Selected Dataset from ComboBox is null!");

					return;
				}

				CRDefaultListModel tmodel = CorelyzerApp.getApp().getTrackListModel();
				TrackSceneNode tnode = (TrackSceneNode) tmodel.elementAt(selectedTrackListId);

				CoreSection sec;

				boolean justAppend = false;

				for (int i = 0; i < ds.getNumTables(); i++) {
					WellLogTable wt = ds.getTable(i);

					String tableName = wt.getName();
					sec = tnode.getCoreSection(tableName);
					if (sec == null) {
						// need to creat new section
						int secid = SceneGraph.addSectionToTrack(tnode.getId(), tnode.getNumCores());
						SceneGraph.setSectionName(tnode.getId(), secid, tableName);
						// property?
						sec = new CoreSection(tableName, secid);
						tnode.addCoreSection(sec);
						CoreGraph.getInstance().notifyListeners();

						// If the dataset table contains section depth offset,
						// use it
						float unitScale;
						switch (wt.getDepthUnits()) {
							case UnitLength.CM:
								unitScale = 0.01f;
								break;

							case UnitLength.M:
								unitScale = 1.0f;
								break;

							case UnitLength.FOOT:
								unitScale = 0.3048f;
								break;

							case UnitLength.INCH:
								unitScale = 0.0254f;
								break;

							case UnitLength.MM:
								unitScale = 0.001f;
								break;

							case UnitLength.YARD:
								unitScale = 0.9144f;
								break;

							default:
								unitScale = 1.0f;
						}

						// Figure out the top depth of a section
						float sectionBeginDepth;
						float sectionTopDepth = wt.getTopDepth(); // in meters

						if (sectionTopDepth != -1) {
							sectionBeginDepth = sectionTopDepth;
						} else if (wt.getDepth_offset() != -1) {
							sectionBeginDepth = wt.getDepth_offset() * unitScale;
						} else {
							sectionBeginDepth = 0.0f;
							justAppend = true;
						}

						SceneGraph.positionSection(tnode.getId(), secid, sectionBeginDepth * 100.0f / 2.54f * SceneGraph.getCanvasDPIX(0), 0);
					}

					// if we created new coresection and add new graph
					// send section to the end of the track
					if (justAppend) {
						SceneGraph.pushSectionToEnd(tnode.getId(), sec.getId());
						sec.setDepth(SceneGraph.getSectionDepth(tnode.getId(), sec.getId()));
					}

					// now we have the section
					// native first, java next for gid
					int gid = SceneGraph.addLineGraphToSection(tnode.getId(), sec.getId(), ds.getId(), // currentDatasetIndex,
							i, row);

					if (gid == -1) {
						return;
					}
					SceneGraph.setLineGraphRange(gid, minVals.elementAt(row), maxVals.elementAt(row));

					Color c = colors.elementAt(row);

					SceneGraph.setLineGraphColor(gid, (c.getRed() / 255.0f), (c.getGreen() / 255.0f), (c.getBlue() / 255.0f));

					Integer t = types.elementAt(row);
					SceneGraph.setLineGraphType(gid, t);

					String fn = this.fieldsTable.getRowLabel(row);
					SceneGraph.setLineGraphLabel(gid, fn);

					// java side
					CoreSectionGraph csg = new CoreSectionGraph(ds.getId() /* currentDatasetIndex */, i, row, gid, tnode);

					csg.setName(tableName);
					tnode.addCoreSectionGraph(csg, sec.getId(), gid);

					// update currnet gid : native code id
					this.selectedTrackId = tnode.getId();
					this.selectedSectionId = sec.getId();
				}

			} // end if all or just one
		} // end adding graphs

		CorelyzerApp.getApp().updateGLWindows();
	}

	private void onMaxTextLostFocus() {
		int field = fieldsTable.getSelectedRow();
		// System.out.println("MODIFIYING FIELD AT ROW: " + field);
		if (field < 0) {
			return;
		}

		try {
			float max;
			max = Float.parseFloat(maxText.getText());
			maxVals.setElementAt(max, field);
		} catch (NumberFormatException exp) {
			System.err.println("Wrong number format! " + maxText.getText());
		}
		// System.out.println("Max text: " + maxVals.elementAt(field));
	}

	private void onMinTextLostFocus() {
		int field = fieldsTable.getSelectedRow();
		// System.out.println("MODIFIYING FIELD AT ROW: " + field);

		if (field < 0) {
			return;
		}

		try {
			float min;
			min = Float.parseFloat(minText.getText());
			minVals.setElementAt(min, field);
		} catch (NumberFormatException exp) {
			System.err.println("Wrong number format!" + minText.getText());
		}
		// System.out.println("Min text: " + minVals.elementAt(field));
	}

	private void onSectionsListChanged() {
		WellLogDataSet ds = (WellLogDataSet) this.datasetList.getSelectedItem();

		// if (currentDatasetIndex < 0) {
		if (ds == null) {
			return;
		}

		this.selectedSectionListId = this.sectionsList.getSelectedIndex();
		if (this.selectedSectionListId == -1) {
			return;
		}

		this.currentTableIndex = this.selectedSectionListId;

		// need to update selectedSectionId
		CRDefaultListModel tmodel = CorelyzerApp.getApp().getTrackListModel();
		TrackSceneNode tnode = (TrackSceneNode) tmodel.elementAt(selectedTrackListId);
		String secname = this.sectionsListModel.getElementAt(this.selectedSectionListId).toString();

		CoreSection sec = tnode.getCoreSection(secname);
		if (sec == null) {
			this.selectedSectionId = -1;
		} else {
			this.selectedSectionId = sec.getId();
		}

		// this.updateFields(this.currentDatasetIndex);
		this.updateFields(ds);

		this.fieldsTable.setRowSelectionInterval(0, 0);
		this.fieldsTable.updateUI();

		this.onFieldsListChanged();
	}

	private void onTypeListAction() {
		// TYPE SELECTED
		int field = fieldsTable.getSelectedRow();

		if (field < 0) {
			return;
		}

		types.setElementAt(typeList.getSelectedIndex(), field);

		// if there is a graph already there then change the type of
		// the graph

		// update current section info f i x m e
		CRDefaultListModel tmodel = CorelyzerApp.getApp().getTrackListModel();
		TrackSceneNode tnode = (TrackSceneNode) tmodel.elementAt(selectedTrackListId);
		String secname = this.sectionsListModel.getElementAt(this.selectedSectionListId).toString();

		CoreSection sec = tnode.getCoreSection(secname);
		if (sec == null) {
			this.selectedSectionId = -1;
		} else {
			this.selectedSectionId = sec.getId();
		}

		WellLogDataSet ds = (WellLogDataSet) this.datasetList.getSelectedItem();

		int gid = SceneGraph.getGraphID(selectedTrackId, selectedSectionId, ds.getId(), // getDatasetId(currentDatasetIndex),
				currentTableIndex, field);

		if (gid < 0) {
			return;
		}

		Integer t = types.elementAt(field);
		SceneGraph.setLineGraphType(gid, t);

		this.onApply();
	}

	public void selectDataset(final int index) {

		if (index >= this.datasets.size() || index < 0) {
			return;
		}

		this.datasetList.setSelectedIndex(index);
	}

	public void setDatasetVec(final Vector<WellLogDataSet> dsvec) {
		if (dsvec.size() <= 0) {
			return;
		}

		this.datasets = dsvec;

		// Update Datalists ComboBox UI
		this.datasetModel.removeAllElements();
		for (int i = 0; i < datasets.size(); i++) {
			WellLogDataSet ds = datasets.elementAt(i);

			// String name = ds.getSourceFilename();
			// name = name.replace('\\', '/');
			// String tokens[] = name.split("/");

			// this.datasetModel.addElement(tokens[tokens.length - 1]);
			this.datasetModel.addElement(ds);
		}
	}

	/*
	 * private int getDatasetId(int datasetIndex) { int datasetId = -1;
	 * 
	 * CoreGraph cg = CoreGraph.getInstance(); if (cg != null) { Session s =
	 * cg.getCurrentSession(); if (s != null) { WellLogDataSet d =
	 * s.getDataset(datasetIndex); if (d != null) { datasetId = d.getId(); } } }
	 * 
	 * return datasetId; }
	 */

	public void setSelectedSectionId(final int id) {
		if (id < 0) {
			return;
		}
		this.selectedSectionId = id;
	}

	public void setSelectedSectionListId(final int id) {
		if (id < 0) {
			return;
		}
		this.selectedSectionListId = id;
	}

	public void setSelectedTrackAndSectionId(final int trackId, final int sectionId) {
		// System.out.println("[Bremen] setSelectedTrackAndSectionId: " +
		// trackId + ", " + sectionId);

		// ids are based on java code might not same as native index
		// this results from deletion feature of tracks and sections
		// find native code index first
		int tid, sid;
		tid = sid = -1;
		int i, j, tsize, ssize;
		boolean found = false;
		CRDefaultListModel tmodel = CorelyzerApp.getApp().getTrackListModel();
		tsize = tmodel.getSize();
		TrackSceneNode tt;
		CoreSection cs;
		for (i = 0; i < tsize; i++) {
			tt = (TrackSceneNode) tmodel.elementAt(i);
			if (trackId == i) {
				tid = tt.getId();
				ssize = tt.getNumCores();
				for (j = 0; j < ssize; j++) {
					cs = tt.getCoreSection(j);
					if (sectionId == j) {
						sid = cs.getId();
						found = true;
						break;
					}
				}
				break;
			}
		}
		if (!found) {
			return;
			// end of index matching
		}

		setSelectedTrackListId(trackId); // java index
		setSelectedSectionListId(sectionId); // java index
		setSelectedTrackId(tid); // native index
		setSelectedSectionId(sid); // native index

		this.sectionsList.setSelectedIndex(sectionId);
		this.onSectionsListChanged();
	}

	public void setSelectedTrackId(final int id) {
		if (id < 0) {
			return;
		}
		this.selectedTrackId = id;
	}

	public void setSelectedTrackListId(final int id) {
		if (id < 0) {
			return;
		}
		this.selectedTrackListId = id;
	}

	// private void updateFields(int dsIdx) {
	private void updateFields(final WellLogDataSet ds) {
		// if (dsIdx < 0) return;
		if (ds == null) {
			return;
		}

		lastSelectedField = -1;

		// clear the fields table and the min/max value vectors
		fieldsTable.clearTable();
		colors.clear();
		types.clear();

		minVals.clear();
		maxVals.clear();
		origMinVals.clear();
		origMaxVals.clear();

		this.allMinVals.clear();
		this.allMaxVals.clear();

		// WellLogDataSet ds = datasets.elementAt(dsIdx);
		WellLogTable t = ds.getTable(this.selectedSectionListId);

		Random generator = new Random(System.currentTimeMillis());
		for (int j = 0; j < t.getNumFields(); j++) {

			String fieldName = t.getHeader(j + 1);
			int gid = SceneGraph.getGraphID(selectedTrackId, selectedSectionId, ds.getId() /* dsIdx */, this.selectedSectionListId, j);

			boolean isShow = gid >= 0; // ? true : false;
			fieldsTable.addRow(isShow, fieldName);

			// if there is already a graph then we need to
			// pull up the info about the graph, otherwise
			// we use defaults
			this.origMinVals.add(t.getColumnMin(j));
			this.origMaxVals.add(t.getColumnMax(j));

			if (!isShow) {
				minVals.add(t.getColumnMin(j));
				maxVals.add(t.getColumnMax(j));
				types.add(0);

				int r = (int) (100 + 0.49803 * generator.nextInt(256));
				int g = (int) (100 + 0.49803 * generator.nextInt(256));
				int b = (int) (100 + 0.49803 * generator.nextInt(256));

				colors.add(new Color(r, g, b));
			} else {
				minVals.add(SceneGraph.getGraphMin(gid));
				maxVals.add(SceneGraph.getGraphMax(gid));
				float r, g, b;
				r = SceneGraph.getLineGraphColorComponent(gid, 0);
				g = SceneGraph.getLineGraphColorComponent(gid, 1);
				b = SceneGraph.getLineGraphColorComponent(gid, 2);
				colors.add(new Color(r, g, b));
				int gt;
				gt = SceneGraph.getLineGraphType(gid);
				types.add(gt);
			}
		}

		this.minText.setText("");
		this.maxText.setText("");

		// collect fields' all min/max
		for (int i = 0; i < t.getNumFields(); i++) {
			float min = 0.0f;
			float max = 0.0f;

			for (int j = 0; j < ds.getNumTables(); j++) {
				WellLogTable table = ds.getTable(j);

				if (j == 0) {
					min = table.getColumnMin(i);
					max = table.getColumnMax(i);
				} else {
					min = min > table.getColumnMin(i) ? table.getColumnMin(i) : min;
					max = max < table.getColumnMax(i) ? table.getColumnMax(i) : max;
				}
			}

			this.allMinVals.add(min);
			this.allMaxVals.add(max);
		}
	}
}
